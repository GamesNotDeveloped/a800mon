import asyncio
import curses

from . import debug
from .actions import ActionDispatcher, Actions, ShortcutInput
from .app import App, Component
from .appstate import AppMode, shortcuts, state
from .breakpoints import BreakpointsViewer
from .cpustate import CpuStateViewer
from .disassembly import DisassemblyViewer
from .displaylist import DisplayListViewer
from .emulator import CAP_MONITOR_BREAKPOINTS
from .history import HistoryViewer
from .rpc import RpcClient, RpcException
from .screenbuffer import ScreenBufferInspector
from .watchers import WatchersViewer
from .shortcutbar import ShortcutBar
from .shortcuts import Shortcut, ShortcutLayer
from .socket import SocketTransport
from .statusupdater import StatusUpdater
from .topbar import TopBar
from .ui import Color, Screen, Window


class AppModeUpdater(Component):
    def __init__(self, dispatcher):
        self._dispatcher = dispatcher
        self._last_paused = None

    async def update(self):
        if self._last_paused is None:
            self._last_paused = state.paused
            self._dispatcher.dispatch(Actions.SYNC_MODE)
            return True
        if state.paused != self._last_paused:
            self._last_paused = state.paused
            self._dispatcher.dispatch(Actions.SYNC_MODE)
            return True
        return False


class BreakpointsWindowUpdater(Component):
    def __init__(self, app, screen, window):
        self._app = app
        self._screen = screen
        self._window = window
        self._last_visible = bool(window.visible)

    async def update(self):
        visible = bool(state.breakpoints_supported)
        if visible == self._last_visible:
            return False
        self._last_visible = visible
        if not visible and self._screen.focused is self._window:
            self._screen.focus(None)
        self._window.visible = visible
        self._app.rebuild_screen()
        return True


async def main(scr, socket_path):
    rpc = RpcClient(SocketTransport(socket_path))
    dispatcher = ActionDispatcher(rpc)
    try:
        caps = await rpc.config()
    except RpcException:
        caps = []
    dispatcher.update_breakpoints_supported(
        CAP_MONITOR_BREAKPOINTS in set(caps)
    )

    wcpu = Window(title="CPU State")
    wdlist = Window(title="DisplayList")
    wwatch = Window(title="Watchers")
    wscreen = Window(title="Screen Buffer")
    wscreen.add_tag("ATASCII", tag_id="atascii", active=True)
    wscreen.add_tag("ASCII", tag_id="ascii", active=False)
    wdisasm = Window(title="Disassembler")
    wdisasm.add_tag("FOLLOW", tag_id="follow", active=True)
    whistory = Window(title="History")
    wbreakpoints = Window(title="Breakpoints")
    wbreakpoints.add_tag("ENABLED", tag_id="bp_enabled", active=False)
    top = Window(border=False)
    bottom = Window(border=False)

    screen_inspector = ScreenBufferInspector(rpc, wscreen)
    disassembly_view = DisassemblyViewer(rpc, wdisasm)
    watchers_view = WatchersViewer(rpc, wwatch)
    breakpoints_view = BreakpointsViewer(rpc, wbreakpoints)
    history_view = HistoryViewer(rpc, whistory, reverse_order=True)
    display_list = DisplayListViewer(rpc, wdlist)
    cpu = CpuStateViewer(wcpu)
    topbar = TopBar(top)
    status_updater = StatusUpdater(
        rpc=rpc,
        dispatcher=dispatcher,
        paused_interval=0.2,
        running_interval=0.05,
    )
    dispatcher.set_after_rpc(status_updater.request_refresh)
    appmode_updater = AppModeUpdater(dispatcher)
    shortcutbar = ShortcutBar(bottom)
    wdisasm.visible = state.disassembly_enabled
    wbreakpoints.visible = state.breakpoints_supported

    def init_screen(scr):
        w, h = scr.size
        wcpu.reshape(x=0, y=h - 5, w=w, h=3)
        left_total_h = max(2, wcpu.y - 3)
        dlist_h = max(1, left_total_h // 2)
        watch_h = max(1, left_total_h - dlist_h)
        wdlist.reshape(x=0, y=2, w=40, h=dlist_h)
        wwatch.reshape(x=0, y=2 + dlist_h, w=40, h=watch_h)
        right_x = wdlist.x + wdlist.w + 2
        right_total = max(1, w - right_x)
        gap = 2
        if right_total <= gap + 2:
            base_screen_w = 1
            base_history_w = 1
        else:
            base_screen_w = (right_total - gap) * 2 // 3
            base_history_w = right_total - gap - base_screen_w
            if base_screen_w < 1:
                base_screen_w = 1
            if base_history_w < 1:
                base_history_w = 1
                base_screen_w = max(1, right_total - gap - base_history_w)

        if wdisasm.visible:
            history_w = max(1, base_history_w - 8)
            disasm_w = max(1, base_history_w - 8)
            screen_w = right_total - history_w - disasm_w - 2 * gap
            if screen_w < 1:
                screen_w = 1
                remaining = max(2, right_total - screen_w - 2 * gap)
                history_w = max(1, remaining // 2)
                disasm_w = max(1, remaining - history_w)

            wscreen.reshape(x=right_x, y=2, w=screen_w, h=wcpu.y - 3)
            wdisasm.reshape(
                x=wscreen.x + wscreen.w + gap,
                y=2,
                w=disasm_w,
                h=wcpu.y - 3,
            )
            history_x = wdisasm.x + wdisasm.w + gap
            history_h = max(1, wcpu.y - 3)
            if wbreakpoints.visible:
                history_top_h = max(1, history_h // 2)
                break_h = max(1, history_h - history_top_h)
                whistory.reshape(
                    x=history_x,
                    y=2,
                    w=history_w,
                    h=history_top_h,
                )
                wbreakpoints.reshape(
                    x=history_x,
                    y=2 + history_top_h,
                    w=history_w,
                    h=break_h,
                )
            else:
                whistory.reshape(
                    x=history_x,
                    y=2,
                    w=history_w,
                    h=history_h,
                )
        else:
            screen_w = base_screen_w
            history_w = base_history_w
            wscreen.reshape(x=right_x, y=2, w=screen_w, h=wcpu.y - 3)
            history_x = wscreen.x + wscreen.w + gap
            history_h = max(1, wcpu.y - 3)
            if wbreakpoints.visible:
                history_top_h = max(1, history_h // 2)
                break_h = max(1, history_h - history_top_h)
                whistory.reshape(
                    x=history_x,
                    y=2,
                    w=history_w,
                    h=history_top_h,
                )
                wbreakpoints.reshape(
                    x=history_x,
                    y=2 + history_top_h,
                    w=history_w,
                    h=break_h,
                )
            else:
                whistory.reshape(
                    x=history_x,
                    y=2,
                    w=history_w,
                    h=history_h,
                )
        top.reshape(x=0, y=0, w=w, h=1)
        bottom.reshape(x=0, y=h - 1, w=w, h=1)

    screen = Screen(scr, layout_initializer=init_screen)
    app = App(
        screen=screen,
        status_updater=status_updater,
        input_timeout_ms=200,
    )
    breakpoints_window_updater = BreakpointsWindowUpdater(
        app=app,
        screen=screen,
        window=wbreakpoints,
    )
    disassembly_view.bind_input(
        screen,
        set_address=lambda addr: dispatcher.dispatch(
            Actions.SET_DISASSEMBLY_ADDR, addr
        ),
        set_input_focus=lambda enabled: dispatcher.dispatch(
            Actions.SET_INPUT_FOCUS, enabled
        ),
        set_input_target=lambda target: dispatcher.dispatch(
            Actions.SET_INPUT_TARGET, target
        ),
        set_input_buffer=lambda text: dispatcher.dispatch(
            Actions.SET_INPUT_BUFFER, text
        ),
    )
    watchers_view.bind_input(screen, dispatcher)
    breakpoints_view.bind_input(screen)
    breakpoints_view.attach_dispatcher(dispatcher)

    def build_shortcuts():
        def action(key, label, action):
            return Shortcut(key, label, lambda: dispatcher.dispatch(action))

        def step_with_follow(action_id):
            def run():
                disassembly_view.enable_follow()
                dispatcher.dispatch(action_id)

            return run

        step = Shortcut(
            curses.KEY_F0 + 5,
            "Step",
            step_with_follow(Actions.STEP),
        )
        step_vblank = Shortcut(
            curses.KEY_F0 + 6,
            "Step VBLANK",
            step_with_follow(Actions.STEP_VBLANK),
        )
        pause = action(curses.KEY_F0 + 8, "Pause", Actions.PAUSE)
        cont = action(curses.KEY_F0 + 8, "Continue", Actions.CONTINUE)
        enter_shutdown = action(27, "Shutdown", Actions.ENTER_SHUTDOWN)
        exit_shutdown = action(27, "Back", Actions.EXIT_SHUTDOWN)

        normal = ShortcutLayer("NORMAL")
        normal.add(step)
        normal.add(step_vblank)
        normal.add(pause)
        normal.add(enter_shutdown)

        debug = ShortcutLayer("DEBUG", color=Color.APPMODE_DEBUG)
        debug.add(step)
        debug.add(step_vblank)
        debug.add(cont)
        debug.add(enter_shutdown)

        shutdown = ShortcutLayer("SHUTDOWN", color=Color.APPMODE_SHUTDOWN)
        shutdown.add(action("c", "Cold start", Actions.COLDSTART))
        shutdown.add(action("w", "Warm start", Actions.WARMSTART))
        shutdown.add(action("t", "Terminate", Actions.TERMINATE))
        shutdown.add(exit_shutdown)

        shortcuts.add(AppMode.NORMAL, normal)
        shortcuts.add(AppMode.DEBUG, debug)
        shortcuts.add(AppMode.SHUTDOWN, shutdown)

        def toggle_dlist():
            new_val = not state.displaylist_inspect
            dispatcher.dispatch(Actions.SET_DLIST_INSPECT, new_val)
            screen.focus(wdlist if new_val else None)

        def toggle_disassembly():
            if not wdisasm.visible:
                if state.disassembly_addr is None:
                    dispatcher.dispatch(
                        Actions.SET_DISASSEMBLY_ADDR, state.cpu.pc & 0xFFFF
                    )
                dispatcher.dispatch(Actions.SET_DISASSEMBLY, True)
                wdisasm.visible = True
                app.rebuild_screen()
                screen.focus(wdisasm)
            elif screen.focused is not wdisasm:
                screen.focus(wdisasm)
            else:
                screen.focus(wdlist if state.displaylist_inspect else None)
                dispatcher.dispatch(Actions.SET_DISASSEMBLY, False)
                wdisasm.visible = False
                app.rebuild_screen()

        def focus_watchers():
            if screen.focused is wwatch:
                screen.focus(None)
            else:
                screen.focus(wwatch)

        def focus_breakpoints():
            if not wbreakpoints.visible:
                return
            if screen.focused is wbreakpoints:
                screen.focus(None)
            else:
                screen.focus(wbreakpoints)

        shortcuts.add_global(Shortcut("s", "Toggle DLIST", toggle_dlist))
        shortcuts.add_global(Shortcut("W", "Watchers", focus_watchers))
        shortcuts.add_global(Shortcut("B", "Breakpoints", focus_breakpoints))
        shortcuts.add_global(Shortcut("d", "Disassembly", toggle_disassembly))
        shortcuts.add_global(
            Shortcut(
                9,
                "ATASCII/ASCII",
                lambda: dispatcher.dispatch(
                    Actions.SET_ATASCII, not state.use_atascii),
            )
        )
        shortcuts.add_global(action("q", "Quit", Actions.QUIT))

    input_processor = ShortcutInput(shortcuts, dispatcher)
    app.add_component(dispatcher)
    app.add_component(cpu)
    app.add_component(disassembly_view)
    app.add_component(watchers_view)
    app.add_component(breakpoints_view)
    app.add_component(input_processor)
    app.add_component(topbar)
    app.add_component(appmode_updater)
    app.add_component(breakpoints_window_updater)
    app.add_component(shortcutbar)
    app.add_component(display_list)
    app.add_component(screen_inspector)
    app.add_component(history_view)

    build_shortcuts()
    await app.loop()


def run(socket_path):
    try:
        curses.wrapper(lambda scr: asyncio.run(main(scr, socket_path)))
    except KeyboardInterrupt:
        pass
    except curses.error:
        try:
            curses.endwin()
        except curses.error:
            pass
        raise
    except Exception:
        try:
            curses.endwin()
        except curses.error:
            pass
        raise
    finally:
        try:
            curses.endwin()
        except curses.error:
            pass
        debug.print_log()
