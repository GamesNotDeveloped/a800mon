import dataclasses
import typing


@dataclasses.dataclass(frozen=True)
class CpuHistoryEntry:
    y: int
    x: int
    pc: int
    op0: int
    op1: int
    op2: int

    @property
    def opbytes(self) -> bytes:
        return bytes((self.op0, self.op1, self.op2))


@dataclasses.dataclass(frozen=True)
class WatcherEntry:
    addr: int
    value: int = 0
    next_value: int = 0
    comment: str = ""


@dataclasses.dataclass(frozen=True)
class BreakpointConditionEntry:
    cond_type: int
    op: int
    addr: int
    value: int


@dataclasses.dataclass(frozen=True)
class BreakpointClauseEntry:
    conditions: tuple[BreakpointConditionEntry, ...]


@dataclasses.dataclass(frozen=True)
class Breakpoint:
    enabled: bool
    clauses: tuple[BreakpointClauseEntry, ...]


@dataclasses.dataclass(frozen=True)
class Status:
    paused: bool
    emu_ms: int
    reset_ms: int
    crashed: bool
    state_seq: int
    machine_type: int

    def __repr__(self) -> str:
        paused = "yes" if self.paused else "no"
        crashed = "yes" if self.crashed else "no"
        return (
            "paused=%s crashed=%s machine_type=%d emu_ms=%d reset_ms=%d state_seq=%d"
            % (
                paused,
                crashed,
                self.machine_type,
                self.emu_ms,
                self.reset_ms,
                self.state_seq,
            )
        )


@dataclasses.dataclass(frozen=True)
class Sysinfo:
    machine_family: int
    os_revision: int
    basic_revision: int
    builtin_game_revision: int
    basic_enabled: bool
    tv_pal: bool


@dataclasses.dataclass
class CpuState:
    xpos: int = 0
    ypos: int = 0
    pc: int = 0
    a: int = 0
    x: int = 0
    y: int = 0
    s: int = 0
    p: int = 0

    N_FLAG = 0x80
    V_FLAG = 0x40
    D_FLAG = 0x08
    I_FLAG = 0x04
    Z_FLAG = 0x02
    C_FLAG = 0x01

    def __repr__(self) -> str:
        n = "N" if (self.p & self.N_FLAG) else "-"
        v = "V" if (self.p & self.V_FLAG) else "-"
        d = "D" if (self.p & self.D_FLAG) else "-"
        i = "I" if (self.p & self.I_FLAG) else "-"
        z = "Z" if (self.p & self.Z_FLAG) else "-"
        c = "C" if (self.p & self.C_FLAG) else "-"
        return (
            f"{self.ypos:3d} {self.xpos:3d} A={self.a:02X} X={self.x:02X} "
            f"Y={self.y:02X} S={self.s:02X} P={n}{v}*-{d}{i}{z}{c} "
            f"PC={self.pc:04X}"
        )


@dataclasses.dataclass(frozen=True)
class GtiaState:
    hposp: tuple[int, int, int, int]
    hposm: tuple[int, int, int, int]
    sizep: tuple[int, int, int, int]
    sizem: int
    grafp: tuple[int, int, int, int]
    grafm: int
    colpm: tuple[int, int, int, int]
    colpf: tuple[int, int, int, int]
    colbk: int
    prior: int
    vdelay: int
    gractl: int


@dataclasses.dataclass(frozen=True)
class AnticState:
    dmactl: int
    chactl: int
    dlist: int
    hscrol: int
    vscrol: int
    pmbase: int
    chbase: int
    vcount: int
    nmien: int
    ypos: int


@dataclasses.dataclass(frozen=True)
class CartSlotState:
    present: int
    cart_type: int
    state: int
    size_kb: int
    raw: int


@dataclasses.dataclass(frozen=True)
class CartState:
    autoreboot: int
    main: CartSlotState
    piggy: CartSlotState


@dataclasses.dataclass(frozen=True)
class JumpsState:
    pcs: tuple[int, ...]


@dataclasses.dataclass(frozen=True)
class PiaState:
    pactl: int
    pbctl: int
    porta: int
    portb: int


@dataclasses.dataclass(frozen=True)
class PokeyState:
    stereo_enabled: int
    audf1: tuple[int, int, int, int]
    audc1: tuple[int, int, int, int]
    audctl1: int
    kbcode: int
    irqen: int
    irqst: int
    skstat: int
    skctl: int
    audf2: typing.Optional[tuple[int, int, int, int]] = None
    audc2: typing.Optional[tuple[int, int, int, int]] = None
    audctl2: typing.Optional[int] = None


@dataclasses.dataclass(frozen=True)
class StackEntry:
    stack_off: int
    value: int


@dataclasses.dataclass(frozen=True)
class StackState:
    s: int
    entries: tuple[StackEntry, ...]


class DisplayListEntry:
    def __init__(self, addr: int, command: int, arg: int):
        self.addr = addr
        self.command = command
        self.arg = arg

    def __eq__(self, other):
        if not isinstance(other, DisplayListEntry):
            return NotImplemented
        return (self.command, self.arg) == (other.command, other.arg)

    @property
    def is_dli(self):
        return bool(self.command & 0x80)

    @property
    def mode(self):
        return self.command & 0x0F

    @property
    def command_name(self):
        if self.mode == 0:
            return "BLANK"
        elif self.mode == 1:
            if self.command & 0x40:
                return "JVB"
            else:
                return "JMP"
        else:
            return f"MODE {self.mode}"

    @property
    def description(self):
        textcommand = ""
        dli_prefix = "DLI " if self.is_dli else ""
        count = 1

        if self.mode == 0:
            count = ((self.command >> 4) & 0x07) + 1
            textcommand = f"{count} {self.command_name}"
        elif self.mode == 1:
            textcommand = f"{self.command_name} {self.arg:04X}"
        else:
            parts = []
            if self.command & 0x40:
                parts.append(f"LMS {self.arg:04X}")
            if self.command & 0x20:
                parts.append("VSCROL")
            if self.command & 0x10:
                parts.append("HSCROL")
            parts.append(self.command_name)
            textcommand = " ".join(parts)
        return f"{dli_prefix}{textcommand}"

    def __repr__(self):
        return f"<{self.addr:04X}: {self.description}>"


class DisplayList:
    def __init__(
        self, start_addr: int = 0, entries: typing.List[DisplayListEntry] = []
    ):
        self.entries = entries
        self.start_addr = start_addr

    def compacted_entries(self):
        if not self.entries:
            return

        run = self.entries[0]
        count = 1

        for e in self.entries[1:]:
            if e == run:
                count += 1
                continue
            yield (count, run)
            run = e
            count = 1

        prefix = f"{count}x " if count > 1 else ""
        yield (count, run)

    def screen_segments(self, dmactl: int):
        from .atari.displaylist import DisplayListMemoryMapper

        rows = DisplayListMemoryMapper(self, dmactl).row_ranges_with_modes()
        segs = []
        for addr, length, mode in rows:
            if addr is None or length == 0:
                continue
            end = addr + length
            if end <= 0x10000:
                segs.append((addr, end, mode))
            else:
                segs.append((addr, 0x10000, mode))
                segs.append((0, end & 0xFFFF, mode))
        if not segs:
            return []
        merged = []
        cur_s, cur_e, cur_mode = segs[0]
        for s, e, mode in segs[1:]:
            if mode == cur_mode and cur_s <= s <= cur_e:
                if e > cur_e:
                    cur_e = e
            else:
                merged.append((cur_s, cur_e, cur_mode))
                cur_s, cur_e, cur_mode = s, e, mode
        merged.append((cur_s, cur_e, cur_mode))
        return merged

    def __iter__(self):
        return iter(self.entries)


@dataclasses.dataclass
class ScreenBuffer:
    start_address: int = 0
    buffer: bytes = b""
    range_index: typing.List[typing.Tuple[int, int, int]] = dataclasses.field(
        default_factory=list
    )
    row_slices: typing.List[
        typing.Union[
            slice,
            typing.Tuple[slice, int],
            typing.Tuple[int, typing.List[slice]],
            typing.Tuple[int, int],
        ]
    ] = dataclasses.field(default_factory=list)

    def get_range(self, addr: int, length: int) -> bytes:
        if length <= 0 or not self.range_index:
            return b""
        addr &= 0xFFFF
        end = addr + length
        if end <= 0x10000:
            return self._get_range_linear(addr, length)
        first_len = 0x10000 - addr
        return self._get_range_linear(addr, first_len) + self._get_range_linear(
            0, length - first_len
        )

    def _get_range_linear(self, addr: int, length: int) -> bytes:
        if length <= 0:
            return b""
        end = addr + length
        parts = []
        remaining = length
        cur = addr
        while remaining > 0:
            for start, stop, offset in self.range_index:
                if start <= cur < stop:
                    take = min(remaining, stop - cur)
                    buf_start = offset + (cur - start)
                    parts.append(self.buffer[buf_start : buf_start + take])
                    cur += take
                    remaining -= take
                    break
            else:
                return b""
        return b"".join(parts)
